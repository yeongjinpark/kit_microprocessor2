//mission



#include <avr/io.h>
#include <avr/interrupt.h>
#define F_CPU 16000000UL
#include <util/delay.h>

#define STOP 0
#define GO 1


volatile int state= STOP;


unsigned char hello[5][8] = {
	0xbd,0xbd,0xbd,0x81,0xbd,0xbd,0xbd,0xbd,	// H

	0x81,0xfd,0xfd,0x81,0xfd,0xfd,0xfd,0x81,	// E

	0xfd,0xfd,0xfd,0xfd,0xfd,0xfd,0xfd,0x81,	// L

	0xfd,0xfd,0xfd,0xfd,0xfd,0xfd,0xfd,0x81,	// L

	0xe7,0xdb,0xbd,0xbd,0xbd,0xbd,0xdb,0xe7	// O
}; //


unsigned char bye[3][8] = {
	0xc1,0xbd,0xbd,0xc1,0xdd,0xbd,0xbd,0xc1,	// B

	0xbd,0xbd,0xbd,0xdb,0xe7,0xe7,0xe7,0xe7,    //Y

	0x81,0xfd,0xfd,0x81,0xfd,0xfd,0xfd,0x81,	// E
}; //


ISR(INT4_vect){
	
	if(state == STOP){  
		state=GO;    //STOP->GO 전환
	}
	
	else{
		state=STOP;   //GO->STOP 전환
	}
	_delay_ms(30);

}


void init(){
	DDRA=0xff;     //a포트 출력
	DDRF=0xff;     //f포트 출력
	
	DDRE=0xcf;      //INT 4,5번 사용
	EICRB=0x0a;     //failing edge
	EIMSK=0x30;     //interrupt en
	sei();          //global interrupt enable
}


void sw1_hello(){      //hello 출력 함수 생성
	int i,j,k=0;
	
	while(1){
		for(i=0; i<5; i++){            //글자 수 5
			for(j=0; j<100; j++){      //글자 유지할 루프 생성
				for(k=0; k<8; k++){     //8x8 행렬
					PORTA=hello[i][k];   //1줄에서 보여줄 데이터 형태
					PORTF= 1<< k;         //1칸씩 줄 이동
					_delay_ms(1);          //반복
				}
			}
		}
	}
}

void sw2_bye(){
	int i,j,k=0;

	while(1){
		for(i=0; i<3; i++){
			for(j=0; j<100; j++){
				for(k=0; k<8; k++){
					PORTA=bye[i][k];
					PORTF= 1<< k;
					_delay_ms(1);
				}
			}
		}

	}
}


int main()
{
	unsigned char data[] ={0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};	// Blank

	init();
	
	while(1){
		if(state ==STOP){          
			PORTF= data[1];
			_delay_ms(1);
	
		}
		else{
			sw1_hello();             
		}
	}
	
}



	unsigned char data[] =

	{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,	// Blank

	0x3c, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3c, 0x00,	// I

	0x22, 0x77, 0xff, 0xff, 0xfe, 0x7c, 0x38, 0x10, 0x00,	// ♥

	0x66, 0x66, 0x7e, 0x3c, 0x18, 0x18, 0x18, 0x3c, 0x00,	// Y

	0x3c, 0x7e, 0x66, 0x66, 0x66, 0x66, 0x7e, 0x3c, 0x00,	// O

	0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x7e, 0x3e, 0x00,	// U

	0x08, 0x18, 0x18, 0x18, 0x10, 0x00, 0x30, 0x30, 0x30}; // !	





	volatile const unsigned char english[26][8]={

			0xe7,0xdb,0xbd,0xbd,0x81,0xbd,0xbd,0xbd,     // A

			0xc1,0xbd,0xbd,0xc1,0xdd,0xbd,0xbd,0xc1,     // B

			0xc3,0xbd,0xfd,0xfd,0xfd,0xbd,0xbd,0xc3,     // C

			0xc1,0xbd,0xbd,0xbd,0xbd,0xbd,0xbd,0xc1,     // D

			0x81,0xfd,0xfd,0x81,0xfd,0xfd,0xfd,0x81,     // E

			0x81,0xfd,0xfd,0x81,0xfd,0xfd,0xfd,0xfd,     // F

			0xe7,0xd9,0xbd,0xfd,0x8d,0xbd,0xdb,0xe7,     // G

			0xbd,0xbd,0xbd,0x81,0xbd,0xbd,0xbd,0xbd,     // H

			0xc3,0xe7,0xe7,0xe7,0xe7,0xe7,0xe7,0xc3,     // I

			0xc3,0xe7,0xe7,0xe7,0xe7,0xe5,0xf5,0xfb,     // J

			0xdd,0xed,0xf5,0xf9,0xf5,0xed,0xdd,0xbd,     // K

			0xfd,0xfd,0xfd,0xfd,0xfd,0xfd,0xfd,0x81,     // L

			0xbd,0x99,0xa5,0xa5,0xa5,0xbd,0xbd,0xbd,     // M

			0xbd,0xbd,0xb9,0xb5,0xad,0x9d,0xbd,0xbd,     // N

			0xe7,0xdb,0xbd,0xbd,0xbd,0xbd,0xdb,0xe7,     // O

			0xe1,0xdd,0xdd,0xdd,0xe1,0xfd,0xfd,0xfd,     // P

			0xe3,0xdd,0xdd,0xdd,0xd5,0xcd,0xc3,0xbf,     // Q

			0xc1,0xbd,0xbd,0xc1,0xdd,0xbd,0xbd,0xbd,     // R

			0xc3,0xbd,0xfd,0xc3,0xbf,0xbf,0xbd,0xc3,     // S

			0x81,0xe7,0xe7,0xe7,0xe7,0xe7,0xe7,0xe7,     // T

			0xbd,0xbd,0xbd,0xbd,0xbd,0xbd,0xbd,0xc3,     // U

			0xbd,0xbd,0xbd,0xbd,0xbd,0xbd,0xdb,0xe7,     // V

			0xbd,0xbd,0xbd,0xbd,0xa5,0xa5,0xa5,0x99,     // W

			0xbd,0xbd,0xd9,0xe7,0xe7,0xdb,0xbd,0xbd,     // X

			0xbd,0xbd,0xbd,0xdb,0xe7,0xe7,0xe7,0xe7,     // Y

			0x81,0xbf,0xdf,0xef,0xf7,0xfb,0xfd,0x81,     // Z

	};



 volatile const unsigned char number[9][8]={
   {0xef,0xe7,0xeb,0xef,0xef,0xef,0xef,0x83},     // 1
   {0xff,0xe7,0xdb,0xdf,0xef,0xf7,0xc3,0xff},     // 2
   {0xff,0xe7,0xdb,0xdf,0xe7,0xdf,0xdb,0xe7},     // 3
   {0xff,0xef,0xf7,0xeb,0xc1,0xef,0xef,0xff},     // 4
   {0xff,0xc3,0xfb,0xe3,0xdf,0xdb,0xe7,0xff},     // 5
   {0xff,0xc7,0xfb,0xe3,0xdb,0xdb,0xe7,0xff},     // 6
   {0xff,0xc3,0xdb,0xdf,0xdf,0xdf,0xdf,0xff},     // 7
   {0xff,0xe7,0xdb,0xdb,0xe7,0xdb,0xdb,0xe7},     // 8
   {0xff,0xe7,0xdb,0xdb,0xc7,0xdf,0xdf,0xdf}};    // 9

#define SW1 1
#define SW2 2
volatile int state=SW1;
ISR(INT4_vect){
 state = SW1;
 _delay_ms(30);
}
ISR(INT5_vect){
 state = SW2;
 _delay_ms(30);
}

int main (){

 if(state == SW1)
  for...........
   if(state == SW2) break;
   for...
    for....
 else
  for
   if(state == SW1) break;
   for
    for
}